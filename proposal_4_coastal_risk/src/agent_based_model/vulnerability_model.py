"""
Agent-Based Vulnerability Model

Spatially-explicit simulation of household vulnerability and adaptation
to compound coastal hazards.
"""

import numpy as np
import pandas as pd
from mesa import Model
from mesa.time import RandomActivation
from mesa.space import MultiGrid
from mesa.datacollection import DataCollector
from typing import Dict, List, Optional, Tuple
import geopandas as gpd


class VulnerabilityModel(Model):
    """
    Agent-based model for coastal vulnerability assessment.

    Simulates household-level vulnerability, risk perception,
    and adaptation decisions in coastal cities facing compound hazards.

    Parameters
    ----------
    city : str
        Name of the coastal city
    n_households : int
        Number of household agents to simulate
    spatial_resolution : float
        Grid cell size in meters
    width : int, optional
        Grid width in cells
    height : int, optional
        Grid height in cells
    """

    def __init__(
        self,
        city: str,
        n_households: int = 10000,
        spatial_resolution: float = 100,
        width: int = 100,
        height: int = 100,
        seed: Optional[int] = None
    ):
        super().__init__()
        self.city = city
        self.n_households = n_households
        self.spatial_resolution = spatial_resolution
        self.random_seed = seed

        if seed is not None:
            np.random.seed(seed)

        # Create spatial grid
        self.grid = MultiGrid(width, height, torus=False)
        self.schedule = RandomActivation(self)

        # Environment parameters
        self.elevation_map = None
        self.flood_depth = None
        self.current_step = 0

        # Economic parameters
        self.median_income = self._get_city_income(city)

        # Initialize agents
        self._create_households()

        # Data collection
        self.datacollector = DataCollector(
            model_reporters={
                "Total_Damage": lambda m: self._calculate_total_damage(),
                "Displaced_Households": lambda m: self._count_displaced(),
                "Adaptation_Rate": lambda m: self._calculate_adaptation_rate(),
                "Average_Risk_Perception": lambda m: self._average_risk_perception()
            },
            agent_reporters={
                "Wealth": "wealth",
                "Risk_Perception": "risk_perception",
                "Adapted": "has_adapted",
                "Damage": "damage"
            }
        )

        # Results storage
        self.results = []

    def _get_city_income(self, city: str) -> float:
        """Get median income for city (placeholder - use real data)."""
        city_income = {
            'Lagos': 2500,    # USD/month
            'Mombasa': 300,
            'Dakar': 200,
            'Maputo': 150
        }
        return city_income.get(city, 500)

    def _create_households(self):
        """Create household agents with heterogeneous characteristics."""
        from .household_agent import HouseholdAgent

        for i in range(self.n_households):
            # Generate household characteristics
            wealth = self._generate_wealth()
            household_size = np.random.choice([1, 2, 3, 4, 5, 6], p=[0.15, 0.25, 0.25, 0.20, 0.10, 0.05])
            education_level = np.random.choice(['low', 'medium', 'high'], p=[0.4, 0.4, 0.2])

            # Create agent
            agent = HouseholdAgent(
                unique_id=i,
                model=self,
                wealth=wealth,
                household_size=household_size,
                education_level=education_level
            )

            # Place agent on grid
            x = np.random.randint(0, self.grid.width)
            y = np.random.randint(0, self.grid.height)
            self.grid.place_agent(agent, (x, y))

            # Add to scheduler
            self.schedule.add(agent)

    def _generate_wealth(self) -> float:
        """Generate household wealth from log-normal distribution."""
        # Log-normal distribution for wealth inequality
        mean_log = np.log(self.median_income)
        sigma_log = 0.8  # Gini-like inequality

        wealth = np.random.lognormal(mean_log, sigma_log)
        return max(wealth, 100)  # Minimum wealth

    def load_elevation_data(self, elevation_map: np.ndarray):
        """
        Load elevation data for the coastal area.

        Parameters
        ----------
        elevation_map : np.ndarray
            2D array of elevation values (meters above sea level)
        """
        if elevation_map.shape != (self.grid.height, self.grid.width):
            raise ValueError("Elevation map shape must match grid dimensions")

        self.elevation_map = elevation_map

    def run(
        self,
        scenarios: pd.DataFrame,
        n_steps: int = 365
    ) -> pd.DataFrame:
        """
        Run the model for multiple hazard scenarios.

        Parameters
        ----------
        scenarios : pd.DataFrame
            Hazard scenarios from Bayesian network
        n_steps : int
            Number of time steps per scenario (days)

        Returns
        -------
        pd.DataFrame
            Simulation results
        """
        all_results = []

        for idx, scenario in scenarios.iterrows():
            print(f"Running scenario {idx + 1}/{len(scenarios)}")

            # Reset model state
            self._reset_scenario()

            # Apply hazard scenario
            self._apply_hazard_scenario(scenario)

            # Run simulation
            for step in range(n_steps):
                self.step()

            # Collect results
            scenario_results = self.datacollector.get_model_vars_dataframe()
            scenario_results['scenario_id'] = idx
            all_results.append(scenario_results)

        # Combine results
        combined_results = pd.concat(all_results, ignore_index=True)
        self.results = combined_results

        return combined_results

    def _reset_scenario(self):
        """Reset model state for new scenario."""
        self.current_step = 0
        self.flood_depth = None
        self.datacollector = DataCollector(
            model_reporters={
                "Total_Damage": lambda m: self._calculate_total_damage(),
                "Displaced_Households": lambda m: self._count_displaced(),
                "Adaptation_Rate": lambda m: self._calculate_adaptation_rate(),
                "Average_Risk_Perception": lambda m: self._average_risk_perception()
            },
            agent_reporters={
                "Wealth": "wealth",
                "Risk_Perception": "risk_perception",
                "Adapted": "has_adapted",
                "Damage": "damage"
            }
        )

        # Reset agents
        for agent in self.schedule.agents:
            agent.reset()

    def _apply_hazard_scenario(self, scenario: pd.Series):
        """
        Apply a compound hazard scenario to the environment.

        Parameters
        ----------
        scenario : pd.Series
            Hazard values (storm surge, sea level, precipitation, etc.)
        """
        if self.elevation_map is None:
            # Generate synthetic elevation if not provided
            self.elevation_map = self._generate_synthetic_elevation()

        # Calculate total water level
        total_water_level = 0

        if 'storm_surge' in scenario:
            total_water_level += scenario['storm_surge']

        if 'slr' in scenario:
            total_water_level += scenario['slr'] / 1000  # mm to m

        # Calculate flood depth at each grid cell
        self.flood_depth = np.maximum(
            total_water_level - self.elevation_map,
            0
        )

        # Add pluvial flooding from precipitation
        if 'precipitation' in scenario:
            # Simplified runoff model
            runoff_depth = scenario['precipitation'] * 0.01  # mm to m, with runoff coefficient
            self.flood_depth += runoff_depth

    def _generate_synthetic_elevation(self) -> np.ndarray:
        """Generate synthetic elevation map for testing."""
        # Create coastal slope
        x = np.linspace(0, self.grid.width, self.grid.width)
        y = np.linspace(0, self.grid.height, self.grid.height)
        X, Y = np.meshgrid(x, y)

        # Simple linear slope from coast (0m) to inland (10m)
        elevation = (X / self.grid.width) * 10

        # Add some noise
        elevation += np.random.normal(0, 0.5, elevation.shape)

        return elevation

    def step(self):
        """Advance model by one step."""
        self.current_step += 1
        self.schedule.step()
        self.datacollector.collect(self)

    def _calculate_total_damage(self) -> float:
        """Calculate total economic damage across all households."""
        total_damage = sum([agent.damage for agent in self.schedule.agents])
        return total_damage

    def _count_displaced(self) -> int:
        """Count number of displaced households."""
        displaced = sum([1 for agent in self.schedule.agents if agent.is_displaced])
        return displaced

    def _calculate_adaptation_rate(self) -> float:
        """Calculate fraction of households that have adapted."""
        adapted = sum([1 for agent in self.schedule.agents if agent.has_adapted])
        return adapted / self.n_households

    def _average_risk_perception(self) -> float:
        """Calculate average risk perception across households."""
        perceptions = [agent.risk_perception for agent in self.schedule.agents]
        return np.mean(perceptions)

    def get_spatial_vulnerability_map(self) -> np.ndarray:
        """
        Generate spatial map of vulnerability.

        Returns
        -------
        np.ndarray
            2D array of vulnerability scores
        """
        vulnerability_map = np.zeros((self.grid.height, self.grid.width))

        for agent in self.schedule.agents:
            x, y = agent.pos
            vulnerability_map[y, x] += agent.get_vulnerability_score()

        return vulnerability_map

    def export_results(self, output_path: str):
        """
        Export simulation results to file.

        Parameters
        ----------
        output_path : str
            Path to save results (CSV or HDF5)
        """
        if self.results is not None and len(self.results) > 0:
            if output_path.endswith('.csv'):
                self.results.to_csv(output_path, index=False)
            elif output_path.endswith('.h5'):
                self.results.to_hdf(output_path, key='results', mode='w')
            else:
                raise ValueError("Output path must end with .csv or .h5")

            print(f"Results exported to {output_path}")
        else:
            print("No results to export. Run simulation first.")
